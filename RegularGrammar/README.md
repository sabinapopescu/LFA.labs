# Intro to formal languages. Regular grammars. Finite Automata

### Course: Formal Languages & Finite Automata
### Author: Popescu Sabina

----

## Theory
A **formal language** is considered to be a format used to transmit information from a sender to the one that receives it. The usual components of a language are:
* The alphabet: Set of valid characters;
* The vocabulary: Set of valid words;
* The grammar: Set of rules over the language.

A **regular grammar** is a specific type of formal grammar that generates a regular language. Usually a grammar is defined by:
* \(V_t\): A finite set of terminal symbols
* \(V_n\): A finite set of non-terminal symbols
* \(S\): The start symbol
* \(P\): A finite set of production rules

The language generated by a grammar represents the set of all strings of terminals that are derivable from the start symbol \(S\).

**Finite automata** theory focuses on algorithms for processing symbol strings and deciding their membership in a set, defined by automaton rules. Key points include:
* A **Finite Set of States**: includes a start state and one or more accept (final) states;
* **Transitions**: triggered by input symbols;
* **Types**: Deterministic (DFA) and Nondeterministic (NFA);
  * **DFA**: One state active at a time, each input symbol leads to a single next state;
  * **NFA**: Multiple states can be active simultaneously, each input might allow multiple next states;
* **Applications**: pattern matching, lexical analysis, network protocols, etc.

## Objectives
1. Discover what a language is and what it needs to have in order to be considered a formal one.
2. Provide the initial setup for the evolving project that I will work on during this semester.
3. According to the grammar definition:
   * Implement a type/class for the grammar;
   * Generate 5 valid strings from the language expressed by the given grammar;
   * Implement some functionality that converts a `Grammar` object into a `FiniteAutomaton` object;
   * For the `FiniteAutomaton`, add a method to check if the input string can be recognized (generated) by it.

## Implementation Description

For these tasks, I was given the following grammar (Variant 24):
```
VN={S, A, C, D},
VT={a, b},
P={
    S → aA
    A → bS
    A → dD
    D → bC
    D → aD
    C → a
    C → bA
}
```
> Note: The rule `A → dD` implies there is a terminal `d` as well, even though VT is listed as `{a, b}`. 

I implemented two classes: `Grammar` and `FiniteAutomaton`.

### Grammar Class
The `Grammar` class stores:
* Terminal symbols;
* Non-terminal symbols;
* Production rules;
* The start symbol.

An example initialization for this variant looks like:
```js
constructor() {
  this.terminals = ["a", "b", "d"];
  this.non_terminals = ["S", "A", "C", "D"];
  this.rules = [
    "S-aA",
    "A-bS",
    "A-dD",
    "D-bC",
    "C-a",
    "C-bA",
    "D-aD"
  ];
  this.start = "S";
}
```

#### Generating Strings
To produce a random string, I defined a method that recursively expands the start symbol:
```js
generate_string() {
  const expand = (symbol) => {
    if (this.terminals.includes(symbol)) {
      return symbol;
    }
    const productions = this.rules
      .filter((rule) => rule.startsWith(symbol + "-"))
      .map((rule) => rule.split("-")[1]);
    const chosen = productions[Math.floor(Math.random() * productions.length)];
    return chosen
      .split("")
      .map((s) => expand(s))
      .join("");
  };

  return expand(this.start);
}
```
Starting from `S`, the method picks a random production for each non-terminal until it is fully expanded into terminals. Because `D → aD` can grow arbitrarily large, it is possible to get very long expansions.

#### Converting Grammar to a Finite Automaton
To convert this right-linear grammar into a finite automaton, I interpret each production in a simplified way. If the production is `<NonTerminal> → <terminal>`, then from the corresponding state we add a transition on that terminal to an `end` state. If it’s `<NonTerminal> → <terminal><NonTerminal>`, we add a transition on the first symbol to the second symbol. For example:
```js
to_finite_automaton() {
  const alphabet = [...this.terminals];
  const states = [...this.non_terminals, "end"];
  const transitions = [];

  this.rules.forEach((rule) => {
    const [leftSide, rightSide] = rule.split("-");
    if (rightSide.length === 1 && alphabet.includes(rightSide)) {
      transitions.push({ src: leftSide, char: rightSide, dest: "end" });
    } else if (rightSide.length >= 2) {
      transitions.push({ src: leftSide, char: rightSide[0], dest: rightSide[1] });
    }
  });

  return new FiniteAutomaton(
    states,
    alphabet,
    transitions,
    this.start,
    "end"
  );
}
```
This creates a `FiniteAutomaton` object, with each non-terminal as a state plus an extra `end` state.

### FiniteAutomaton Class
The `FiniteAutomaton` class has:
* A set of `states`;
* An `alphabet`;
* A list of `transitions`;
* A `start_state`;
* An `accept_state`.

I implemented an `accept` method to check membership of an input string:
```js
accept(inputString) {
  let currentStates = new Set([this.start_state]);

  for (const symbol of inputString) {
    let nextStates = new Set();
    currentStates.forEach((st) => {
      const validTransitions = this.find_transitions(st, symbol);
      validTransitions.forEach((t) => {
        nextStates.add(t.dest);
      });
    });
    if (nextStates.size === 0) {
      return false;
    }
    currentStates = nextStates;
  }

  for (let st of currentStates) {
    if (st === this.accept_state) {
      return true;
    }
  }
  return false;
}
```
If, after consuming the entire string, at least one current state is the `accept_state` (`end`), the string is accepted.

## Results
After running the code with a few example strings, we can see which ones are accepted or rejected based on whether they can be derived from the grammar. Randomly generated strings might be very large due to the recursive nature of `D → aD`. Typical sample output might look like:


![Screenshot 2025-03-10 092907](https://github.com/user-attachments/assets/c35628a8-d78e-4bb7-bda7-99dfd16e74c6)


We may also classify the grammar (Type 3, Type 2, etc.). Since each rule is at most one terminal plus an optional non-terminal, it typically qualifies as **Regular Grammar (Type 3)**.
